#include <cmath>
#include <vector>
#include <iostream>
#include <fstream>

#include "computeballvalvearea.h"

double ballValveArea(double theta,
		             std::vector<double> &areaFunction)
{
	int thetaCount = areaFunction.size();
	double thetaStep = M_PI/double(thetaCount);

	if (theta==0.0)
	{
		return areaFunction[0];
    }
	else if((theta > 0.0) && (theta < M_PI))
	{
	    /* if theta between 0 and Pi/2 
	         valve closing */

		int thetaIndxHigh = floor(theta/thetaStep);
		int thetaIndxLow  = ceil(theta/thetaStep);
		if(thetaIndxHigh > (areaFunction.size()-1))
			thetaIndxHigh = areaFunction.size()-1;
		if(thetaIndxLow > (areaFunction.size()-1))
			thetaIndxLow = areaFunction.size()-2;
		if(thetaIndxHigh==thetaIndxLow)
		{
			if(thetaIndxHigh+1 < (areaFunction.size()-1))
				thetaIndxHigh = thetaIndxHigh + 1;
		    else
		    	thetaIndxLow = thetaIndxLow - 1;
		}
		return interpolate(areaFunction[thetaIndxLow],
				           areaFunction[thetaIndxHigh],
						   double(thetaIndxLow)*thetaStep,
						   double(thetaIndxHigh)*thetaStep,
						   theta);
	}
	else if((theta >= M_PI) && (theta < 2.0*M_PI))
	{
	    /* if theta between Pi/2 and Pi
	         valve openning */

		int thetaIndxHigh = floor(theta/thetaStep);
		int thetaIndxLow  = ceil(theta/thetaStep);
		if(thetaIndxHigh > (areaFunction.size()-1))
			thetaIndxHigh = areaFunction.size()-1;
		if(thetaIndxLow > (areaFunction.size()-1))
			thetaIndxLow = areaFunction.size()-2;
		if(thetaIndxHigh==thetaIndxLow)
		{
			if(thetaIndxHigh+1 < (areaFunction.size()-1))
				thetaIndxHigh = thetaIndxHigh + 1;
		    else
		    	thetaIndxLow = thetaIndxLow - 1;
		}
		return interpolate(areaFunction[thetaIndxLow],
				           areaFunction[thetaIndxHigh],
						   double(thetaIndxLow)*thetaStep,
						   double(thetaIndxHigh)*thetaStep,
						   theta);
	}
	else if(theta==2.0*M_PI)
	{
		return areaFunction[areaFunction.size()-1];
	}
	else
	{
		/* theta out of range */
	}
}

double interpolate(double y0,
		           double y1,
				   double x0,
				   double x1,
				   double x)
{
	return y0 + (x - x0)*((y1-y0)/(x1-x0));
}

void computeBallValveAreaFunction(valveProperties &valveGeom,
		                          int thetaCount,
		                          std::vector<double> &areaFunction)
{
	double thetaStep = (M_PI/2.0)/double(thetaCount);

	for (int i = 0; i < thetaCount; i++)
	{
		double theta = double(i)*thetaStep;
		areaFunction.push_back(computeBallValveArea(valveGeom,theta));
	}
	int halfCount = areaFunction.size();
	for (int i = halfCount; i > 0; i--)
		areaFunction.push_back(areaFunction[i-1]);
}

double computeBallValveArea(valveProperties &valveGeom,
		                    double alphaOpen)
{
//	double ballInternalRadius = valveGeom.ballInternalRadius;
	int xCount = valveGeom.spanCount;

	/* inlet properties */
	double inletRadius = valveGeom.inletRadius;
	double valveRadius = valveGeom.valveRadius;

	std::vector<double> inletX;
	std::vector<double> inletY;

	std::vector<double> valveInletX;
	std::vector<double> valveInletY;

	int valveSpanCount = 0;
	int inletSpanCount = 0;

	if (inletRadius > valveRadius)
	{
		valveSpanCount = valveGeom.spanCount;
		inletSpanCount = floor((inletRadius/valveRadius)*double(valveSpanCount));
	}
	else
	{
		inletSpanCount = valveGeom.spanCount;
		valveSpanCount = floor((valveRadius/inletRadius)*double(inletSpanCount));
	}

	/* define inlet coordinates */
	circleCoordinates(inletRadius,
			          inletSpanCount,
					  inletX,
					  inletY);

	circleCoordinates(valveRadius,
			          valveSpanCount,
					  valveInletX,
					  valveInletY);

	/*
	std::ofstream fout("testCircle.dat");

	int loopSize = 0;
	int outerLoop = 0;

	if(inletX.size() < valveInletX.size())
	{
		loopSize = inletX.size();
		outerLoop = valveInletX.size();

	    for (int i = 0; i < loopSize; i++)
	    {
		    fout << inletX[i] << '\t' 
			     << inletY[i] << '\t'
			     << valveInletX[i] << '\t'
			     << valveInletY[i] << std::endl;

	    }

	    for (int i = loopSize; i < outerLoop; i++)
	    {
		    fout << '\t' << '\t' 
			     << '\t' << '\t'
			     << valveInletX[i] << '\t'
			     << valveInletY[i] << std::endl;

	    }

	}
	else
	{
		loopSize = valveInletX.size();
		outerLoop = inletX.size();

    	for (int i = 0; i < loopSize; i++)
	    {
	    	fout << inletX[i] << '\t' 
		    	 << inletY[i] << '\t'
		    	 << valveInletX[i] << '\t'
		    	 << valveInletY[i] << std::endl;

	    }
	    for (int i = loopSize; i < outerLoop; i++)
	    {
		    fout << inletX[i] << '\t' 
			     << inletY[i] << std::endl; 

	    }
	}
	*/

//	exit(1);

	int yCount = valveGeom.spanCount;
	//double yStep = ballInternalRadius/double(yCount);

	double h = valveGeom.h;
	
	double yOffSet = h*sin(alphaOpen);

	std::vector<double> valveX;
	std::vector<double> valveY;

	std::vector<double> valveOpenX;
	std::vector<double> valveOpenY;

	int count = 0;
	
	/* need to not used "inletY" for projection if
	      the diameter of ball internal diameter does
		  not equal the inlet diameter - change in future */

	for (int i = 0; i < valveInletX.size(); i++)
	{
		double l = sqrt(pow(inletY[i],2) + pow((h/2),2));
		double alpha = asin(inletY[i]/l) + alphaOpen;

		valveX.push_back(inletX[i]);

//		double l = sqrt(pow(valveInletY[i],2) + pow((h/2),2));
//		double alpha = asin(valveInletY[i]/l) + alphaOpen;

		valveX.push_back(valveInletX[i]);
		valveY.push_back(yp(l,alpha));
		count++;

		if(sqrt(pow(valveX[i],2) + pow(valveY[i],2)) < inletRadius)
		{
			valveOpenX.push_back(inletX[i]);

//			valveOpenX.push_back(valveInletX[i]);
			valveOpenY.push_back(yp(l,alpha));
		}
	}

	for (int i = 0; i < valveInletX.size(); i++)
	{
		double l = sqrt(pow(inletY[i],2) + pow((h/2),2));
		double alpha = asin(inletY[i]/l) + alphaOpen;

    	valveX.push_back(inletX[i]);

//		double l = sqrt(pow(valveInletY[i],2) + pow((h/2),2));
//		double alpha = asin(valveInletY[i]/l) + alphaOpen;

//		valveX.push_back(valveInletX[i]);
		valveY.push_back(-yp(l,alpha)+yOffSet);

		if(sqrt(pow(valveX[i+count-1],2) + pow(valveY[i+count-1],2)) < inletRadius)
		{
			valveOpenX.push_back(inletX[i]);

//			valveOpenX.push_back(valveInletX[i]);
			valveOpenY.push_back(-yp(l,alpha)+yOffSet);
		}
	}

	bool valveClosed = true;

	if(valveOpenY.size()!=0) 
		valveClosed = false;

	if(valveClosed)
		return 0.0;

	double areaEllipseNeg = 0.0;
	double areaEllipse    = 0.0; 
	for (int i = 0; i < valveOpenY.size()-1; i++)
	{
		if(valveOpenY[i] > 0.0)
			areaEllipseNeg = areaEllipseNeg 
				+ (((valveOpenY[i+1]+valveOpenY[i])/2.0)*(valveOpenX[i]-valveOpenX[i+1]));
		if(valveOpenY[i] < 0.0)
			areaEllipse = areaEllipse 
				+ (((valveOpenY[i+1]+valveOpenY[i])/2.0)*(valveOpenX[i]-valveOpenX[i+1]));
	}
	double areaCircle = 0.0;
	for (int i = 0; i < inletX.size(); i++)
	{
		if((inletX[i] > valveOpenX[0])) 
        {
			if(inletY[i] > 0.0)
//				areaCircle = areaCircle 
//					+ (((inletY[i+1]+inletY[i])/2.0)*(inletX[i]-inletX[i+1]));
				areaCircle = areaCircle 
					+ (((valveInletY[i+1]+valveInletY[i])/2.0)*(valveInletX[i]-valveInletX[i+1]));

		}
	}

	double areaInlet = pow(inletRadius,2)*M_PI;
	double areaOpen = 2.0*(0.25*areaInlet - areaEllipseNeg - areaCircle) 
		                   - 2.0*areaEllipse;
	if(valveRadius < inletRadius)
		areaInlet = pow(valveRadius,2)*M_PI;

	bool fullOpen = true;
	for(int i = 0; i < valveX.size(); i++)
	{
		if(sqrt(pow(valveX[i],2)+pow(valveY[i],2)) > inletRadius)
			fullOpen = false;
	}
	if(areaOpen < 0.0)
		areaOpen = 0.0;
	else if(alphaOpen == 0.0)
		areaOpen = areaInlet;
	else if(alphaOpen == 2.0*M_PI)
		areaOpen = areaInlet; //pow(valveRadius,2)*M_PI;
	else if(fullOpen)
		areaOpen = areaInlet; //pow(valveRadius,2)*M_PI;

	return areaOpen;
}

double xp(double h,
		  double alpha)
{
	return h*sin((M_PI/2.0)-alpha);
}

double yp(double h,
		  double alpha)
{
	return h*sin(alpha);
}

double circleCoordinatesX(double radius,
		                  double y)
{
    double angle = acos(y/radius); 
    return sin(angle)*radius;
}

double circleCoordinatesY(double radius,
		                  double x)
{
    double angle = asin(x/radius); 
    return cos(angle)*radius;
}

void circleCoordinates(double radius,
		               int angleSteps,
		               std::vector<double> &x,
			           std::vector<double> &y)
{
	double angleStep = (M_PI/2.0)/double(angleSteps);
	for (int i = 0; i < angleSteps+1; i++)
	{
		double angle = angleStep*double(i);
		x.push_back(cos(angle)*radius);
		y.push_back(sin(angle)*radius);
	}
}


	/* need to line up X cordinates between valve and inlet */

/*
	
	std::ofstream foutb("before.dat");

	for (int i = 0; i < inletX.size(); i++)
	{
		foutb << inletX[i] << '\t' 
			 << valveInletX[i] << std::endl;
	}

	if(inletRadius > valveRadius)
	{
		std::cout << std::endl;
		std::cout << "working on it...." << std::endl;
		std::cout << std::endl;
	    std::vector<double> tmpX;
	    std::vector<double> tmpY;
		int i = inletX.size();
		while (inletX[i] <= valveRadius)
		{
			tmpX.push_back(inletX[i]); 
			tmpY.push_back(circleCoordinatesY(valveRadius,
					                          inletX[i]));

		    std::cout << valveInletX[i] << '\t' << 
				'\t' << tmpX[i] << inletRadius << std::endl;

			i--;
		}
		for (int j = 0; j > tmpX.size(); j++)
		{
			valveInletX[valveInletX.size()-1-j] = tmpX[j];
			valveInletY[valveInletX.size()-1-j] = tmpY[j];
		}
	}
	else
	{
	    std::vector<double> tmpX;
	    std::vector<double> tmpY;
		int i = valveInletX.size();
		while (inletX[i] < inletRadius)
		{

			tmpX.push_back(inletX[i]); 
			tmpY.push_back(circleCoordinatesY(inletRadius,
					                            inletX[i]));
			i--;
		}
		for (int j = valveInletX.size()-1; j > i; j--)
		{
			valveInletX[j] = tmpX[j];
			valveInletY[j] = tmpY[j];
		}
	}

	std::cout << std::endl;
	std::cout << "inletX size: " << inletX.size() << std::endl;
	std::cout << std::endl;

	std::ofstream fouta("afterInlet.dat");

	for (int i = inletX.size(); i >= 0; i--)
	{
		fouta << i << '\t' 
			 << inletX[i] << std::endl;
	}

	std::ofstream foutaa("afterValve.dat");

	for (int i = valveInletX.size(); i >= 0; i--)
	{
		foutaa << i << '\t' 
			 << valveInletX[i] << std::endl;
	}


*/

